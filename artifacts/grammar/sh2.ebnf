(* sh2 Grammar - EBNF *)
(* This is a descriptive grammar for the sh2 language *)

program = { import_stmt } , { function_def } ;

(* Imports *)
import_stmt = "import" , string_literal ;

(* Function definitions *)
function_def = "func" , identifier , "(" , [ param_list ] , ")" , block ;
param_list = identifier , { "," , identifier } ;

(* Blocks *)
block = "{" , stmt_list , "}" ;
stmt_list = { stmt_sep } , [ statement , { stmt_seps , statement } ] , { stmt_sep } ;
stmt_seps = stmt_sep , { stmt_sep } ;
stmt_sep = ";" | ? NEWLINE ? ; (* Lexer treats newlines as whitespace; explicit NEWLINE tokens do not exist *)

(* Statements *)
statement = let_stmt
          | run_stmt
          | exec_stmt
          | print_stmt
          | print_err_stmt
          | if_stmt
          | while_stmt
          | for_stmt
          | for_map_stmt
          | try_catch_stmt
          | case_stmt
          | with_stmt
          | subshell_stmt
          | group_stmt
          | spawn_stmt
          | pipe_stmt
          | return_stmt
          | exit_stmt
          | break_stmt
          | continue_stmt
          | set_stmt
          | call_stmt
          | export_stmt
          | unset_stmt
          | source_stmt
          | sh_stmt
          | cd_stmt
          | wait_stmt
          | and_then_stmt
          | or_else_stmt
          ;

let_stmt = "let" , identifier , "=" , expression ;
run_stmt = "run" , "(" , [ builtin_arg_list ] , ")" ;
exec_stmt = "exec" , "(" , [ arg_list ] , ")" ;
print_stmt = "print" , "(" , expression , ")" ;
print_err_stmt = "print_err" , "(" , expression , ")" ;
call_stmt = identifier , "(" , [ pos_arg_list ] , ")" ;
set_stmt = "set" , lvalue , "=" , expression ;
export_stmt = "export" , "(" , string_literal , [ "," , expression ] , ")" ;
unset_stmt = "unset" , "(" , string_literal , ")" ;
source_stmt = "source" , "(" , expression , ")" ;
sh_stmt = "sh" , "(" , string_literal , ")" | "sh" , block ;
cd_stmt = "cd" , "(" , expression , ")" ;
wait_stmt = "wait" , [ "(" , expression , ")" ] ;
return_stmt = "return" , [ expression ] ;
exit_stmt = "exit" , [ expression ] ;
break_stmt = "break" ;
continue_stmt = "continue" ;

if_stmt = "if" , expression , block , { elif_clause } , [ else_clause ] ;
elif_clause = "elif" , expression , block ;
else_clause = "else" , block ;

while_stmt = "while" , expression , block ;
for_stmt = "for" , identifier , "in" , for_iterable , block ;
for_iterable = expression
             | expression , ".." , expression
             | "(" , expression , ".." , expression , ")"
             | "(" , [ expression , { "," , expression } ] , ")" ;
for_map_stmt = "for" , "(" , identifier , "," , identifier , ")" , "in" , identifier , block ;

try_catch_stmt = "try" , block , "catch" , block ;

case_stmt = "case" , expression , "{" , { case_arm } , "}" ;
case_arm = pattern , { "|" , pattern } , "=>" , block ;
pattern = string_literal | "glob" , "(" , string_literal , ")" | "_" ;

with_stmt = "with" , with_modifier , block ;
with_modifier = "env" , [ "{" , [ env_bindings ] , "}" ]
              | "cwd" , "(" , expression , ")" (* semantic restriction: must be a string literal (enforced in lowering) *)
              | "log" , "(" , expression , [ "," , "append" , "=" , bool_literal ] , ")"
              | "redirect" , "{" , [ redirect_spec ] , "}"
              ;
env_bindings = identifier , "=" , expression , { "," , identifier , "=" , expression } ;
redirect_spec = redirect_item , { "," , redirect_item } ;
redirect_item = "stdout" , ":" , stdout_spec
              | "stderr" , ":" , stderr_spec
              | "stdin" , ":" , stdin_spec ;

stdout_spec = output_target | "[" , output_target , { "," , output_target } , "]" ;
stderr_spec = output_target | "[" , output_target , { "," , output_target } , "]" ;
stdin_spec = input_target ; (* Stdin does not support list *)

output_target = "file" , "(" , expression , [ "," , "append" , "=" , bool_literal ] , ")"
              | "to_stdout" , "(" , ")"
              | "to_stderr" , "(" , ")"
              | "inherit_stdout" , "(" , ")"
              | "inherit_stderr" , "(" , ")"
              | "stdout" (* legacy: same as to_stdout() *)
              | "stderr" (* legacy: same as to_stderr() *) ;

input_target = "file" , "(" , expression , ")"
             | "heredoc" , "(" , string_literal , ")" ;

subshell_stmt = "subshell" , block ;
group_stmt = "group" , block ;
spawn_stmt = "spawn" , ( block | statement ) ;

pipe_stmt = "pipe" , pipe_segment , "|" , pipe_segment , { "|" , pipe_segment }
          | run_call , "|" , pipe_segment , { "|" , pipe_segment } ;

pipe_segment = run_call | sudo_call | block | each_line_block ;
run_call = "run" , "(" , [ builtin_arg_list ] , ")" ;
sudo_call = "sudo" , "(" , [ builtin_arg_list ] , ")" ;
each_line_block = "each_line" , identifier , block ;

and_then_stmt = statement , "&&" , statement ;
or_else_stmt = statement , "||" , statement ;

(* Expressions *)
expression = or_expr ;
or_expr = and_expr , { "||" , and_expr } ;
and_expr = compare_expr , { "&&" , compare_expr } ;
compare_expr = concat_expr , [ compare_op , concat_expr ] ;
compare_op = "==" | "!=" | "<" | "<=" | ">" | ">=" ;
concat_expr = arith_expr , { "&" , arith_expr } ; (* note: parser enforces whitespace around & *)
arith_expr = term , { ( "+" | "-" ) , term } ;
term = unary_expr , { ( "*" | "/" | "%" ) , unary_expr } ;
unary_expr = [ "!" | "-" ] , primary_expr ;

primary_expr = literal
             | identifier
             | "(" , expression , ")"
             | call_expr
             | capture_expr
             | list_expr
             | map_expr
             | index_expr
             | field_expr
             | builtin_expr
             ;

call_expr = identifier , "(" , [ pos_arg_list ] , ")" ;
capture_expr = "capture" , "(" , [ builtin_arg_list | pipeline ] , ")" ;
pipeline = capture_stage , { "|" , capture_stage } ;
capture_stage = run_call | sudo_call | identifier ; (* identifier here handles capture(cmd) *)
list_expr = "[" , [ expression , { "," , expression } ] , "]" ;
map_expr = "{" , [ map_entry , { "," , map_entry } ] , "}" ;
map_entry = string_literal , ":" , expression ;
index_expr = primary_expr , "[" , expression , "]" ;
field_expr = primary_expr , "." , identifier ;

builtin_expr = "arg" , "(" , expression , ")"
             | "args"
             | "status" , "(" , ")"
             | "pid" , "(" , ")"
             | "ppid" , "(" , ")"
             | "uid" , "(" , ")"
             | "pwd" , "(" , ")"
             | "self_pid" , "(" , ")"
             | "argv0" , "(" , ")"
             | "argv" , "(" , ")"
             | "argc" , "(" , ")"
             | "env" , "(" , expression , ")"
             | "env" , "." , identifier
             | "exists" , "(" , expression , ")"
             | "is_dir" , "(" , expression , ")"
             | "is_file" , "(" , expression , ")"
             | "is_symlink" , "(" , expression , ")"
             | "is_exec" , "(" , expression , ")"
             | "is_readable" , "(" , expression , ")"
             | "is_writable" , "(" , expression , ")"
             | "is_non_empty" , "(" , expression , ")"
             | "len" , "(" , expression , ")"
             | "count" , "(" , expression , ")"
             | "join" , "(" , expression , "," , expression , ")"
             | "split" , "(" , expression , "," , expression , ")"
             | "lines" , "(" , expression , ")"
             | "glob" , "(" , expression , ")"  (* bash-only; returns sorted list of matched paths *)
             | "trim" , "(" , expression , ")"
             | "replace" , "(" , expression , "," , expression , "," , expression , ")"
             | "matches" , "(" , expression , "," , expression , ")"
             | "contains" , "(" , expression , "," , expression , ")"
             | "contains_line" , "(" , expression , "," , expression , ")"
             | "starts_with" , "(" , expression , "," , expression , ")"
             | "input" , "(" , expression , ")"
             | "confirm" , "(" , expression , [ "," , "default" , "=" , bool_literal ] , ")"
             | "bool_str" , "(" , expression , ")"
             | sudo_call
             | "sh" , "(" , expression , [ "," , arg_list ] , ")"
             | "which" , "(" , expression , ")"
             ;

arg_list = expression , { "," , expression } ; (* Deprecated/Legacy: use pos_arg_list or builtin_arg_list *)
pos_arg_list = expression , { "," , expression } ;
builtin_arg_list = ( expression | named_arg ) , { "," , ( expression | named_arg ) } ;
named_arg = identifier , "=" , expression ;
lvalue = identifier | "env" , "." , identifier ;

(* Note: sudo(...) and sh(...) accept mixed positional/named arguments.
   Semantic restrictions (literal-only options, valid option names) are
   enforced during parsing/lowering, not by grammar productions. *)

(* Literals *)
literal = string_literal | number | bool_literal ;
string_literal = normal_string | raw_string | interpolated_string ;

(* Normal strings are strict literals *)
normal_string = '"' , { string_char } , '"' ;

raw_string = 'r"' , { raw_string_char } , '"' ;

(* Interpolated strings support expression interpolation.
   Use \{ and \} to produce literal braces.
   Note: String literals inside holes are not yet supported due to lexer limitations. *)
interpolated_string = '$"' , { interp_char | "{" , expression , "}" } , '"' ;
bool_literal = "true" | "false" ;
number = digit , { digit } ;

(* Lexical *)
identifier = letter , { letter | digit | "_" } ;
letter = "a" | "b" | (* ... *) | "z" | "A" | (* ... *) | "Z" ;
digit = "0" | "1" | (* ... *) | "9" ;
string_char = ? any character except '"' and unescaped newline ? ;
raw_string_char = ? any character except '"' ? ;
interp_char = ? any character except '"', unescaped '{', and unescaped newline; '\{' and '\}' produce literal braces ? ;
