func main() {
    # Create temp dir for test
    let raw_tmp = capture(run("mktemp", "-d"), allow_fail=true)
    let tmp = trim(raw_tmp)
    if status() != 0 {
        print_err("Failed to create tmp dir")
        exit(1)
    }
    
    # Create an executable in the temp dir
    let bin = path_join(tmp, "mycmd")
    write_file(bin, "#!/bin/sh\necho mycmd-ok\n")
    run("chmod", "+x", bin)
    
    # Save original PATH
    let orig_path = env.PATH
    
    # Test 1: PATH with empty segment in middle (should treat as .)
    # PATH="/nope::/also-nope" means: /nope, then ., then /also-nope
    cd(tmp)
    export("PATH", "/nope::/also-nope")
    let p1 = which("mycmd")
    if p1 != "" {
        if status() == 0 {
            print("mid_empty=true")
        } else {
            print("mid_empty=false")
        }
    } else {
        print("mid_empty=false")
    }
    
    # Test 2: Leading empty segment
    # PATH=":/usr/bin" means . comes first
    export("PATH", ":/usr/bin")
    let p2 = which("mycmd")
    if p2 != "" {
        if status() == 0 {
            print("lead_empty=true")
        } else {
            print("lead_empty=false")
        }
    } else {
        print("lead_empty=false")
    }
    
    # Test 3: Trailing empty segment
    # PATH="/nope:" means /nope, then .
    export("PATH", "/nope:")
    let p3 = which("mycmd")
    if p3 != "" {
        if status() == 0 {
            print("trail_empty=true")
        } else {
            print("trail_empty=false")
        }
    } else {
        print("trail_empty=false")
    }
    
    # Restore PATH and cleanup
    export("PATH", orig_path)
    run("rm", "-rf", tmp, allow_fail=true)
    
    print("all_tests_done=true")
}
