#!/usr/bin/env bash
__sh2_check() { local s="$1"; local loc="$2"; local mode="$3"; if (( s != 0 )); then if [[ "$mode" == "return" ]]; then return "$s"; else if [[ -n "$loc" ]]; then printf 'Error in %s\n' "$loc" >&2; fi; exit "$s"; fi; fi; }
__sh2_err_handler() {
  local s=$?
  local loc="${__sh2_loc:-}"
  if [[ "${BASH_COMMAND}" == *"(exit "* ]]; then return $s; fi
  if (( ${__sh2_suppress_err_depth:-0} > 0 )); then return "$s"; fi
  if [[ -z "$loc" ]]; then return $s; fi
  if [[ "$loc" == "${__sh2_last_err_loc:-}" && "$s" == "${__sh2_last_err_status:-}" ]]; then return $s; fi
  __sh2_last_err_loc="$loc"
  __sh2_last_err_status="$s"
  printf "Error in %s\n" "$loc" >&2
  return $s
}
set -o errtrace
trap '__sh2_err_handler' ERR
__sh2_parse_args() {
  local out="" key val
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --) shift; while [ "$#" -gt 0 ]; do out="${out}P	${1}
"; shift; done; break ;;
      --*=*) key="${1%%=*}"; val="${1#*=}"; out="${out}F	${key}	${val}
" ;;
      --*) key="$1"; if [ "$#" -gt 1 ] && [ "${2}" != "--" ] && [[ ! "$2" =~ ^-- ]]; then val="$2"; shift; else val="true"; fi; out="${out}F	${key}	${val}
" ;;
      *) out="${out}P	${1}
" ;;
    esac
    shift
  done
  printf '%s' "$out"
}
__sh2_args_positionals() { printf '%s' "$1" | awk '/^P\t/ { sub(/^P\t/, ""); print }'; }
__sh2_list_get() { printf '%s' "$1" | awk -v i="$2" 'NR==i+1 { printf "%s", $0; exit }'; }
main() {
  local __sh2_loc=""
  __sh2_loc="tests/fixtures/parse_args_positional_marker.sh2:2:3"
  a="${__sh2_parsed_args}"
  __sh2_status=$?
  __sh2_check "$__sh2_status" "${__sh2_loc:-}"
  printf '%s\n' 'p0='"$( __sh2_list_get "$( __sh2_args_positionals "$a" )" $(( 0 )) )"
  printf '%s\n' 'p1='"$( __sh2_list_get "$( __sh2_args_positionals "$a" )" $(( 1 )) )"
  printf '%s\n' 'p2='"$( __sh2_list_get "$( __sh2_args_positionals "$a" )" $(( 2 )) )"
}

__sh2_parsed_args="$(__sh2_parse_args "$@")"
__sh2_status=0
main "$@"
