(* sh2 Grammar - EBNF *)
(* Descriptive grammar for the devctl Steps 1â€“8 subset *)

(* NOTE: Top-level statements are NOT allowed. A file contains function definitions only. *)

program       = { function_def } ;

function_def  = "func" , identifier , "(" , [ param_list ] , ")" , block ;
param_list    = identifier , { "," , identifier } ;

block         = "{" , { statement } , "}" ;

(* Statements (subset) *)
statement     = let_stmt
              | set_stmt
              | run_pipeline_stmt
              | print_stmt
              | print_err_stmt
              | if_stmt
              | case_stmt
              | with_stmt
              | sh_stmt
              | return_stmt
              | exit_stmt
              ;

(* No ';' statement separators in blocks; statements are separated by newlines in the source. *)

let_stmt      = "let" , identifier , "=" , expr ;
set_stmt      = "set" , lvalue , "=" , expr ;

print_stmt     = "print" , "(" , expr , ")" ;
print_err_stmt = "print_err" , "(" , expr , ")" ;

(* sh(...) currently accepts ONLY a string literal, not an arbitrary expression. *)
sh_stmt       = "sh" , "(" , string_lit , ")" ;

return_stmt   = "return" , [ expr ] ;
exit_stmt     = "exit" , [ expr ] ;

if_stmt       = "if" , expr , block , [ "else" , block ] ;

case_stmt     = "case" , expr , "{" , { case_arm } , "}" ;
case_arm      = pattern , "=>" , block ;
pattern       = string_lit | "_" ;

with_stmt     = "with" , with_mod , block ;
with_mod      = "env" , "{" , env_bindings , "}"
              | "cwd" , "(" , expr , ")"
              | "redirect" , "{" , redirect_spec , "}" ;

env_bindings  = identifier , "=" , expr , { "," , identifier , "=" , expr } ;

redirect_spec = redirect_item , { "," , redirect_item } ;
redirect_item = ("stdout" | "stderr" | "stdin") , ":" , redirect_target ;

redirect_target =
                "stdout"
              | "stderr"
              | "file" , "(" , expr , [ "," , "append" , "=" , bool_lit ] , ")"
              | "heredoc" , "(" , string_lit , ")"
              ;

(* Pipelines are supported between run(...) calls. *)
run_pipeline_stmt = run_call , { "|" , run_call } ;
run_call      = "run" , "(" , [ arg_list ] , ")" ;
arg_list      = expr , { "," , expr } ;

(* Expressions *)
expr          = or_expr ;
or_expr       = and_expr , { "||" , and_expr } ;
and_expr      = cmp_expr , { "&&" , cmp_expr } ;
cmp_expr      = concat_expr , [ cmp_op , concat_expr ] ;
cmp_op        = "==" | "!=" | "<" | "<=" | ">" | ">=" ;

concat_expr   = primary , { "&" , primary } ;

primary       = literal
              | identifier
              | "(" , expr , ")"
              | builtin
              ;

(* lvalues *)
lvalue        = identifier | "env" , "." , identifier ;

(* Builtins (documented subset) *)
builtin       = "status" , "(" , ")"
              | "env" , "." , identifier
              | "exists" , "(" , expr , ")"
              | "is_dir" , "(" , expr , ")"
              | "is_file" , "(" , expr , ")"
              | "arg" , "(" , number , ")"
              ;

(* Literals *)
literal       = string_lit | number | bool_lit ;
string_lit    = '"' , { string_char } , '"' ;
bool_lit      = "true" | "false" ;
number        = digit , { digit } ;

identifier    = letter , { letter | digit | "_" } ;
letter        = ? ASCII letter ? ;
digit         = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
string_char   = ? any char except '"' and unescaped newline ? ;
