(*
  sh2 Language Grammar (EBNF) â€” descriptive

  This is a descriptive grammar for the sh2 language as implemented by sh2c.
  It aims to match behavior validated by the test suite.

  Notation:
    =      definition
    |      alternation
    (...)  grouping
    [...]  optional
    {...}  repetition (zero or more)

  NOTE: Statements in blocks are newline-separated; semicolons are not statement
  separators. Newline handling is lexical and not expressed directly in EBNF.
*)

(* =========================
   Top-level program
   ========================= *)

Program            = { ImportStatement } , { FunctionDefinition } ;

ImportStatement    = "import" , StringLiteral ;

FunctionDefinition = "func" , Identifier , "(" , [ ParameterList ] , ")" , Block ;
ParameterList      = Identifier , { "," , Identifier } ;

Block              = "{" , { Statement } , "}" ;


(* =========================
   Statements
   ========================= *)

Statement
  = LetStatement
  | SetStatement
  | PrintStatement
  | PrintErrStatement
  | IfStatement
  | WhileStatement
  | ForStatement
  | TryCatchStatement
  | CaseStatement
  | WithStatement
  | SpawnStatement
  | WaitStatement
  | ReturnStatement
  | ExitStatement
  | BreakStatement
  | ContinueStatement
  | ExportStatement
  | UnsetStatement
  | SourceStatement
  | ExecStatement
  | ExpressionStatement
  ;

LetStatement      = "let" , Identifier , "=" , Expression ;
SetStatement      = "set" , LValue , "=" , Expression ;
LValue            = Identifier | EnvDot | IndexExpression | FieldExpression ;

PrintStatement    = "print" , "(" , [ ArgList ] , ")" ;
PrintErrStatement = "print_err" , "(" , [ ArgList ] , ")" ;

ExportStatement   = "export" , "(" , StringLiteral , [ "," , Expression ] , ")" ;
UnsetStatement    = "unset" , "(" , StringLiteral , ")" ;
SourceStatement   = "source" , "(" , Expression , ")" ;

ExecStatement     = "exec" , "(" , [ ArgList ] , ")" ;

WaitStatement     = "wait" , [ "(" , Expression , ")" ] ;

ReturnStatement   = "return" , [ Expression ] ;
ExitStatement     = "exit" , [ Expression ] ;
BreakStatement    = "break" ;
ContinueStatement = "continue" ;

ExpressionStatement = Expression ;


(* =========================
   Control flow
   ========================= *)

IfStatement    = "if" , Expression , Block , { "elif" , Expression , Block } , [ "else" , Block ] ;
WhileStatement = "while" , Expression , Block ;

ForStatement
  = "for" , Identifier , "in" , Expression , Block
  | "for" , "(" , Identifier , "," , Identifier , ")" , "in" , Identifier , Block ;

TryCatchStatement = "try" , Block , "catch" , Block ;

CaseStatement = "case" , Expression , "{" , { CaseArm } , "}" ;
CaseArm       = CasePatternList , "=>" , Block ;
CasePatternList = CasePattern , { "|" , CasePattern } ;

CasePattern
  = "_"                              (* default wildcard *)
  | "glob" , "(" , StringLiteral , ")" (* glob(...) pattern *)
  | Expression                       (* e.g. a string literal / other expr *)
  ;

(* =========================
   with-scoped modifiers
   ========================= *)

WithStatement = "with" , WithModifier , Block ;

WithModifier
  = WithEnv
  | WithCwd
  | WithRedirect
  | WithLog
  ;

WithEnv = "env" , "{" , [ EnvBindingList ] , "}" ;
EnvBindingList = EnvBinding , { "," , EnvBinding } ;
EnvBinding = Identifier , ":" , Expression ;

WithCwd = "cwd" , "(" , Expression , ")" ;

WithLog = "log" , "(" , Expression , [ "," , "append" , "=" , BoolLiteral ] , ")" ;

WithRedirect = "redirect" , "{" , RedirectSpec , "}" ;
RedirectSpec = RedirectItem , { "," , RedirectItem } ;

RedirectItem = ( "stdin" | "stdout" | "stderr" ) , ":" , RedirectTarget ;

RedirectTarget
  = "stdout"
  | "stderr"
  | "file" , "(" , Expression , [ "," , "append" , "=" , BoolLiteral ] , ")"
  | "heredoc" , "(" , StringLiteral , ")"
  | Expression
  ;


(* =========================
   Concurrency
   ========================= *)

SpawnStatement = "spawn" , ( Block | Statement ) ;


(* =========================
   Expressions
   ========================= *)

Expression = PipelineExpression ;

(* Pipeline has the lowest precedence; stages are expressions. *)
PipelineExpression = OrExpression , { "|" , OrExpression } ;

(* Textual boolean operators (verified by tests): and/or. *)
OrExpression  = AndExpression , { "or" , AndExpression } ;
AndExpression = CompareExpression , { "and" , CompareExpression } ;

CompareExpression = ConcatExpression , [ CompareOp , ConcatExpression ] ;
CompareOp = "==" | "!=" | "<" | "<=" | ">" | ">=" ;

ConcatExpression = AddExpression , { "&" , AddExpression } ;
AddExpression    = MulExpression , { ( "+" | "-" ) , MulExpression } ;
MulExpression    = UnaryExpression , { ( "*" | "/" | "%" ) , UnaryExpression } ;

UnaryExpression  = [ "!" | "-" ] , PostfixExpression ;

PostfixExpression
  = PrimaryExpression ,
    { CallSuffix | IndexSuffix | FieldSuffix }
  ;

CallSuffix  = "(" , [ ArgList ] , ")" ;
IndexSuffix = "[" , Expression , "]" ;
FieldSuffix = "." , Identifier ;

PrimaryExpression
  = Literal
  | Identifier
  | EnvDot
  | "(" , Expression , ")"
  | RunCall
  | ShCall
  | CaptureCall
  | TryRunCall
  ;

RunCall = "run" , "(" , [ ArgList ] , [ "," , RunOptionList ] , ")" ;
RunOptionList = RunOption , { "," , RunOption } ;
RunOption = "allow_fail" , "=" , BoolLiteral ;

ShCall = "sh" , "(" , StringLiteral , ")" ;   (* string literal only *)

CaptureCall = "capture" , "(" , Expression , ")" ;

TryRunCall = "try_run" , "(" , [ ArgList ] , ")" ;

ArgList = Expression , { "," , Expression } ;

IndexExpression = PostfixExpression , "[" , Expression , "]" ;
FieldExpression = PostfixExpression , "." , Identifier ;


(* =========================
   Literals and lexical items
   ========================= *)

Literal = StringLiteral | Number | BoolLiteral | ListLiteral | MapLiteral ;

ListLiteral = "[" , [ ArgList ] , "]" ;
MapLiteral  = "{" , [ MapEntry , { "," , MapEntry } ] , "}" ;
MapEntry    = StringLiteral , ":" , Expression ;

BoolLiteral = "true" | "false" ;
Number      = Digit , { Digit } ;

(* String forms are intentionally abstracted as a terminal category here.
   Implementations may support normal / interpolated / raw / multiline forms. *)
StringLiteral = STRING_LITERAL ;

(* Identifier excludes reserved keywords. This is a lexical constraint:
   IDENTIFIER MUST NOT be any reserved keyword such as:
     env, true, false, if, elif, else, while, for, case, try, catch, with,
     import, func, let, set, return, exit, break, continue, spawn, wait,
     print, print_err, run, exec, sh, capture, try_run, export, unset, source,
     and, or, glob, stdout, stderr, stdin, file, heredoc, log, cwd, redirect, append.
*)
Identifier = IDENTIFIER ;

EnvDot = "env" , "." , Identifier ;

Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
